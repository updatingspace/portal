"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ColorPicker = void 0;
const tslib_1 = require("tslib");
const jsx_runtime_1 = require("react/jsx-runtime");
const React = tslib_1.__importStar(require("react"));
const react_color_1 = require("@uiw/react-color");
const useControlledState_1 = require("../../../hooks/useControlledState/index.js");
const Popup_1 = require("../../Popup/index.js");
const Select_1 = require("../../Select/index.js");
const components_1 = require("./components/index.js");
const constants_1 = require("./constants.js");
const types_1 = require("./types.js");
const utils_1 = require("./utils.js");
const ColorPicker = ({ size, value, defaultValue = constants_1.DEFAULT_COLOR, onUpdate, open, onOpenChange, defaultOpen = false, withAlpha = false, compact = false, }) => {
    const [anchor, setAnchor] = React.useState(null);
    const [modeState, setModeState] = React.useState(types_1.Modes.Hex);
    const [color, setColor] = (0, useControlledState_1.useControlledState)(value, defaultValue, onUpdate);
    const isInternalUpdateRef = React.useRef(false);
    const [hsva, setHsva] = React.useState(() => (0, utils_1.convertSelectedModeColorToHsva)(color, types_1.Modes.Hex, withAlpha));
    React.useEffect(() => {
        if (isInternalUpdateRef.current) {
            isInternalUpdateRef.current = false;
            return;
        }
        setHsva((0, utils_1.convertSelectedModeColorToHsva)(color, types_1.Modes.Hex, withAlpha));
    }, [color, withAlpha]);
    const [isOpen, setIsOpen] = (0, useControlledState_1.useControlledState)(open, defaultOpen, onOpenChange);
    const [inputValue, setInputValue] = React.useState(() => (0, utils_1.getTextValueByMode)(hsva, modeState, withAlpha));
    React.useEffect(() => {
        setInputValue((0, utils_1.getTextValueByMode)(hsva, modeState, withAlpha));
    }, [hsva, modeState, withAlpha]);
    const updateHsva = React.useCallback((updates) => {
        const newHsva = { ...hsva, ...updates };
        setHsva(newHsva);
        const newHexValue = withAlpha ? (0, react_color_1.hsvaToHexa)(newHsva) : (0, react_color_1.hsvaToHex)(newHsva);
        isInternalUpdateRef.current = true;
        setColor(newHexValue);
    }, [hsva, setColor, withAlpha]);
    const handleModeChange = (newMode) => {
        setModeState(newMode);
    };
    const handleInputChange = (val) => {
        setInputValue(val);
    };
    const applyInputValue = React.useCallback(() => {
        const newHsva = (0, utils_1.convertSelectedModeColorToHsva)(inputValue, modeState, withAlpha);
        setHsva(newHsva);
        const newHexValue = withAlpha ? (0, react_color_1.hsvaToHexa)(newHsva) : (0, react_color_1.hsvaToHex)(newHsva);
        isInternalUpdateRef.current = true;
        setColor(newHexValue);
    }, [inputValue, modeState, withAlpha, setColor]);
    return ((0, jsx_runtime_1.jsxs)(React.Fragment, { children: [(0, jsx_runtime_1.jsx)(components_1.ColorDisplay, { hsva: hsva, withAlpha: withAlpha, onClick: () => setIsOpen(!isOpen), onColorChange: updateHsva, ref: setAnchor, size: size, compact: compact }), (0, jsx_runtime_1.jsx)(Popup_1.Popup, { open: isOpen, className: (0, constants_1.b)('popup'), placement: [
                    'bottom-start',
                    'bottom-end',
                    'left-start',
                    'left-end',
                    'top-start',
                    'top-end',
                ], anchorElement: anchor, onOpenChange: setIsOpen, disableTransition: true, children: (0, jsx_runtime_1.jsxs)("div", { className: (0, constants_1.b)('handlers-container'), children: [(0, jsx_runtime_1.jsx)(react_color_1.Saturation, { hsva: hsva, onChange: (newColor) => updateHsva({ ...newColor, a: hsva.a }), className: (0, constants_1.b)('saturation'), radius: 4, pointer: (props) => ((0, jsx_runtime_1.jsx)(components_1.ColorPointer, { left: props.left, top: props.top, transform: 'translate(-50%, -50%)' })) }), (0, jsx_runtime_1.jsx)(react_color_1.Hue, { className: (0, constants_1.b)('slider'), hue: hsva.h, onChange: (newHue) => updateHsva(newHue), pointerProps: { className: (0, constants_1.b)('pointer') }, radius: 4, pointer: (props) => ((0, jsx_runtime_1.jsx)(components_1.ColorPointer, { left: props.left, top: props.top, transform: 'translate(-50%, -25%)' })) }), withAlpha && ((0, jsx_runtime_1.jsx)(react_color_1.Alpha, { hsva: hsva, onChange: (newAlpha) => updateHsva(newAlpha), className: (0, constants_1.b)('slider'), pointerProps: { className: (0, constants_1.b)('pointer') }, radius: 4, pointer: (props) => ((0, jsx_runtime_1.jsx)(components_1.ColorPointer, { left: props.left, top: props.top, transform: 'translate(-50%, -25%)' })) })), (0, jsx_runtime_1.jsxs)("div", { className: (0, constants_1.b)('inputs'), children: [(0, jsx_runtime_1.jsx)(Select_1.Select, { options: Object.values(types_1.Modes).map((val) => ({
                                        content: val,
                                        value: val,
                                    })), multiple: false, value: [modeState], onUpdate: (val) => handleModeChange(val[0]) }), modeState === types_1.Modes.Hex && ((0, jsx_runtime_1.jsx)(components_1.HexInput, { value: inputValue, withAlpha: withAlpha, onChange: handleInputChange, onBlur: applyInputValue })), modeState === types_1.Modes.Rgb && ((0, jsx_runtime_1.jsx)(components_1.RgbInputs, { hsva: hsva, withAlpha: withAlpha, onChange: (color) => updateHsva(color.hsva) }))] })] }) })] }));
};
exports.ColorPicker = ColorPicker;
//# sourceMappingURL=ColorPicker.js.map
